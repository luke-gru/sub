#!/usr/bin/env ruby
# vim: set ft=ruby
# frozen_string_literal: true
require "debug"

USAGE = <<EOF
Usage: sub COMMANDLINE -- PATTERN/SUBSTITUTION[/OPTIONS]

sub substitutes the pattern in every word in the command line with the
substitution if the word matches the pattern. Only the first pattern in
every word is substituted unless the 'g' option is given. There are various
options that change the way substitutions are performed or the way matches
are made. Patterns can have regular expression wildcards (special characters)
in them, and the regular expression engine used is Ruby's.

See [https://docs.ruby-lang.org/en/master/Regexp.html#class-Regexp-label-Special+Characters]
for more information on the special characters that can be used inside patterns.

Ex: sub ld -m elf_i386 ex4.o -o ex4 -- ex4/ex5
    This will output the following, and then execute it:
    ld -m elf_i386 ex5.o -o ex5
EOF

FLAGS = [
  # per substitution flags
  { flag: 'f', name: :first_match, desc: "Substitute first matching word only.",
    example: "sub wget https://wget.com -- wget/curl/f #=> curl https://wget.com",
  },
  { flag: 'l', name: :last_match, desc: "Substitute last matching word only",
    example: "sub ls -al -- l//l #=> ls -a",
  },
  { flag: 'L', name: :literal, desc: "Interpret wildcards in pattern as literals",
    example: "sub cp here.txt there.txt -- ./_/L #=> cp here_txt there_txt",
  },
  { flag: 'i', name: :ignorecase, desc: "Set pattern to ignore the case of the match",
    example: "sub cp here.txt there.txt -- CP/mv/i #=> mv here.txt there.txt",
  },
  { flag: 'g', name: :general, desc: "General substitution: substitute all matches in every word",
    example: "sub cp here.txt there.txt -- ./_/g #=> __ ________ _________",
  },
  { flag: 'e', name: :expand_star, desc: "Expand star in commandline after replacements are made",
    example: [ "sub ls '*' -- //e #=> ls bin README",
               "sub ls hi -- hi/*/e #=> ls bin README", ]
  },
  # global flags
  { flag: 'o', name: :output_only, desc: "Print the command instead of executing it" },
  { flag: 'c', name: :copy_to_clipboard, desc: "Copy the command to clipboard instead of executing it" },
  { flag: 'I', name: :interactive, desc: "Set interactive mode: shows the command and asks if you want to execute it" },
  { flag: 'v', name: :verbose, desc: "Set verbose mode" },
  { flag: 'D', name: :debug, desc: "Set debug mode" },
]

def print_help
  output = String.new
  output << USAGE << "\n"
  FLAGS.each do |fhash|
    output << "-#{fhash[:flag]}:\t#{fhash[:desc]}\n"
    if ex = fhash[:example]
      case ex
      when String
        output << "  \t  ex: #{ex}\n"
      when Array
        ex.each do |x|
          output << "  \t  ex: #{x}\n"
        end
      end
    end
  end
  $stdout.puts output
end

def parse_argv_and_sub_strs(argv)
  ret_argv = []
  sub_strs = []
  if argv.size == 0
    require "readline"
    line = Readline.readline "cmd: ", true
    ret_argv.replace line.strip.split(/\s+/)
    line = Readline.readline "sub: ", true
    sub_strs << line.strip
  else
    last_dashdash_idx = argv.rindex('--')
    argv.each_with_index do |arg, i|
      if arg == '--' && i == last_dashdash_idx
        j = i+1
        while sub_str = argv[j]
          sub_strs << sub_str
          j += 1
        end
        break
      else
        ret_argv << arg
      end
    end
  end
  if sub_strs.empty?
    cmd = ret_argv.shift
    if cmd == "--help" || cmd == "-h"
      print_help
      exit 0
    end
    exec cmd, *ret_argv
  end
  [ret_argv, sub_strs]
end

argv, sub_strs = parse_argv_and_sub_strs(ARGV)

def flag(flags_str, char)
  flag = flags_str.include?(char)
  flags_str.delete!(char)
  flag
end

def flag_by_name(name)
  FLAGS.each do |fhash|
    if fhash[:name] == name
      return fhash[:flag]
    end
  end
  nil
end

def parse_sub_strs(sub_strs)
  ret = []
  pats = []
  subs = []
  match_flags = []
  global_flags = {
    interactive: nil,
    output_only: nil,
    copy_to_clipboard: nil,
    verbose: nil,
    debug: nil,
  }
  raw_flags = []
  sub_strs.each do |sub_str|
    pat, sub, flags = sub_str.split('/') # FIXME: allow / to be preceded by \ (escaped)
    pat = pat.to_s.dup
    sub = sub.to_s.dup
    pat.strip!
    sub.strip!
    flags = flags.to_s.dup
    flags.strip!
    raw_flags << flags.dup
    flags_hash = {
      first_match: flag(flags, flag_by_name(:first_match)),
      last_match: flag(flags, flag_by_name(:last_match)),
      expand_star: flag(flags, flag_by_name(:expand_star)),
      literal: flag(flags, flag_by_name(:literal)),
      ignorecase: flag(flags, flag_by_name(:ignorecase)),
      general: flag(flags, flag_by_name(:general)),
    }

    unless global_flags[:interactive]
      global_flags[:interactive] = flag(flags, flag_by_name(:interactive)) || ARGV.size == 0
    end
    unless global_flags[:output_only]
      global_flags[:output_only] = flag(flags, flag_by_name(:output_only))
    end
    unless global_flags[:copy_to_clipboard]
      global_flags[:copy_to_clipboard] = flag(flags, flag_by_name(:copy_to_clipboard))
    end
    unless global_flags[:verbose]
      global_flags[:verbose] = flag(flags, flag_by_name(:verbose))
    end
    unless global_flags[:debug]
      global_flags[:debug] = flag(flags, flag_by_name(:debug))
    end
    unless flags.empty?
      $stderr.puts "Warning: unknown flag#{'s' if flags.size != 1}: #{flags}"
    end
    pats << pat
    subs << sub
    match_flags << flags_hash
  end


  ret << pats << subs << match_flags << raw_flags << global_flags
end

pats, subs, flags_hashes, raw_flags, global_flags = parse_sub_strs(sub_strs)

if pats.empty? && flags_hashes.empty? && global_flags.empty?
  $stderr.puts "Incorrect substitution, format is: pattern/substitution[/options]"
  exit 1
end

def build_regexps(pats, flags_hashes)
  ret = []
  pats.each_with_index do |pat, idx|
    flags = flags_hashes[idx]
    regexp_opts = String.new
    regexp_opts << 'i' if flags.fetch(:ignorecase)
    ret << if flags.fetch(:literal)
      Regexp.new Regexp.escape(pat), regexp_opts
    else
      Regexp.new(pat, regexp_opts)
    end
  end
  ret
end

regexps = build_regexps(pats, flags_hashes)

def argv_replace!(argv, regexps, subs, flags)
  raise ArgumentError unless [regexps.size, subs.size, flags.size].uniq.size == 1
  stop_substs = Array.new(regexps.size, false)
  num_replacements = 0
  ret_argv = []

  argv.each_with_index do |arg, _arg_i|
    regexps.each_with_index do |regexp, i|
      next if flags[i].fetch(:last_match)
      if arg =~ regexp && !stop_substs[i]
        stop_subst[i] = true if flags[i].fetch(:first_match)
        if flags[i].fetch(:general)
          new_arg = arg.gsub(regexp, subs[i])
          scan_size = arg.scan(regexp).size
        else
          new_arg = arg.sub(regexp, subs[i])
          scan_size = arg.scan(regexp).size
          scan_size = 1 if scan_size > 1
        end
        if new_arg != arg# || new_arg == subs[i]
          num_replacements += scan_size
        end
        arg = new_arg
      end
    end
    ret_argv << arg.dup
  end

  ret_argv.reject! { |arg| arg.strip.empty? }

  regexps.each_with_index do |regexp, i|
    begin
      if flags[i].fetch(:last_match)
        ret_argv.reverse_each do |arg|
          if arg =~ regexp
            if flags[i].fetch(:general)
              new_arg = arg.gsub(regexp, subs[i])
              scan_size = arg.scan(regexp).size
            else
              new_arg = arg.sub(regexp, subs[i])
              scan_size =  arg.scan(regexp).size
              scan_size = 1 if scan_size > 1
            end
            if new_arg != arg
              num_replacements += scan_size
              arg.replace(new_arg)
              raise 'next regexp'
            end
          end
        end
      end
    rescue StandardError => e
      raise unless e.message == 'next regexp'
      # continue
    end
  end

  #if flags.fetch(:last_match)
    #last_subst_el = nil
    #argv.reverse.find { |e| Array === e ? last_subst_el = e : nil }
    #argv.map! do |arg|
      #case arg
      #when String
        #arg
      #when Array
        #if last_subst_el.equal?(arg)
          #num_replacements += 1
          #arg[1]
        #else
          #arg[0]
        #end
      #end
    #end
  #else
    #argv.map! do |arg|
      #case arg
      #when String
        #arg
      #when Array
        #arg[1]
      #end
    #end
  #end

  #if flags.fetch(:expand_star)
    #ret_argv.map! do |arg|
      #if arg == '*'
        #Dir['*'].to_a
      #else
        #arg
      #end
    #end
    #ret_argv.flatten!
  #end
  argv.replace(ret_argv)
  num_replacements
end

num_replacements = argv_replace!(argv, regexps, subs, flags_hashes)

def copy!(cmd_line, global_flags)
  cmd_line = cmd_line.dup
  cmd_line << "\n" if cmd_line.empty?
  if /linux/i =~ RUBY_PLATFORM
    copy_bin = "xclip"
    copy_cmd = "xclip -selection clipboard"
    copy_proc = lambda do |f|
      system("#{copy_cmd} < #{f.path}", out: "/dev/null")
    end
  elsif /darwin/i =~ RUBY_PLATFORM
    copy_bin = "pbcopy"
    copy_cmd = copy_bin
    copy_proc = lambda do |f|
      system("cat #{f.path} | #{copy_cmd}", out: "/dev/null")
    end
  else
    $stderr.puts "Warning: don't know how to get copy command for #{RUBY_PLATFORM}"
    global_flags[:output_only] = true
    return
  end
  system("which #{copy_bin}", out: "/dev/null")
  unless $?.success?
    $stderr.puts "Warning: can't find #{copy_bin}, please install it and put it in your PATH"
    global_flags[:output_only] = true
    return
  end
  require "tempfile"
  Tempfile.create("sub_cmd") do |f|
    f.write cmd_line
    f.flush
    copy_proc.call(f)
    puts "Copied" if $?.success?
  end
end

def exec_cmd(argv, regexps, subs, raw_flags, num_replacements, global_flags)
  if global_flags.fetch(:debug)
    puts "Patterns: #{regexps.inspect}"
    puts "Substitutions: #{subs.inspect}"
    puts "Flags: #{raw_flags.inspect}"
  end
  if global_flags.fetch(:verbose)
    puts "#{num_replacements} replacement#{'s' if num_replacements != 1}"
  end

  if argv.empty?
    copy!("", global_flags) if global_flags.fetch(:copy_to_clipboard)
    if global_flags.fetch(:output_only)
      puts ""
    else
      puts "Nothing to execute"
    end
    exit 0
  end

  cmd = argv.shift
  cmd_line = "#{cmd} #{argv.join(' ')}"
  action = global_flags.fetch(:copy_to_clipboard) ? "copy" : "execute"
  if global_flags.fetch(:interactive) && !global_flags.fetch(:output_only)
    $stdout.puts "Would you like to #{action} the following command? [y(es),n(o)]"
    $stdout.puts cmd_line
    ans = $stdin.gets().strip
    if ans !~ /y(es)?/i # treat as no
      exit 0
    end
  end
  if global_flags.fetch(:output_only) || !global_flags.fetch(:interactive)
    $stdout.puts cmd_line
    $stdout.flush
  end
  copy!(cmd_line, global_flags) if global_flags.fetch(:copy_to_clipboard)
  exit 0 if global_flags.fetch(:output_only) || global_flags.fetch(:copy_to_clipboard)
  begin
    exec cmd, *argv
  rescue SystemCallError => e
    if e.class == Errno::ENOENT
      # act like a shell
      $stderr.puts "#{cmd}: command not found"
    else
      $stderr.puts "#{e.class}: #{e.message}"
    end
    exit e.errno
  end
end

exec_cmd(argv, regexps, subs, raw_flags, num_replacements, global_flags)
